# lab1-1
本次实验的重难点为匹配注释和int、float常量<br>
## 匹配注释
匹配注释分为两种，//类型与/\*\*/类型。<br>
匹配/\*\*/的方式为识别两端的/\*和*/,中间使用非贪婪模式.*?匹配。与正则表达式略有不同的是antlr4里  '.' 是可以匹配换行符\n的（正则表达式中不行）。同时，注释除了以\*/结尾，还可能以文件结束符结尾，因此匹配的表达式为

    '/*'.*?('*/' | EOF)

//类型的匹配方式是开头为//，两个/中间可以插入人一个\\\n(或者\\\r\n,linux与windows中换行符不同)，结尾是不以\为倒数第二个字符的换行符，即遇到\\n时继续识别,同时也可能以文件结束符结尾。<br>
一开始我选择的方法是

	'/' ('\\' ('\n' | '\r\n'))*? '/' 
    (.*?'\\'('\n' | '\r\n'))*
	.*?('\n' | EOF | '\r\n')
	
即先识别出两个/，以及两个/之间可能的\\换行。再用贪婪模式识别中间的注释以及\\换行，此处不能用非贪婪模式因为结尾有\n，非贪婪会直接跳过这一部分<br>
这种方法有一种问题，因为使用了贪婪模式，如果这一段注释下面的代码中使用了\\\n这类型的字符串，贪婪模式会直接将这一块也识别为注释，这显然是错误的。对此我思考了很久没有想到直接识别的方法<br>
大概上厕所时逆向思维比较强，我反应过来只要以'\n'结尾，同时不以\\为倒数第二个，中间的内容全部不管就可以了，即采用～的方法规定结尾处的内容。这种识别方法的结尾还有一种特殊情况，//\n，没有任何注释内容直接结尾，因此要多加一种模式。因此表达式为

	'/' ('\\' ('\n' | '\r\n'))*? '/' (
		('\n' | EOF | '\r\n')
		| (.*? ~'\\' ('\n' | EOF | '\r\n'))
	)
第一部分与前种方法一样，识别出两个/和中间可能的换行，然后识别直接结尾的情况，有内容时识别结尾不是\\\n而是\n的结尾即可。

## 匹配常量
匹配常量比注释要简单一点，虽然表达式很长但只要对着文档的分类进行匹配即可。int常量只有十进制，八进制和十六进制3种模式，分别按照不同的开头部分匹配即可<br>

    [1-9][0-9]*
	| '0' [0-7]*
	| ('0x' | '0X') [0-9a-fA-F]*;
浮点常量比较多，除了10和16两种进制的普通浮点数，还有科学计数法表示的浮点数。分别有eE和pP衔接，加上省略小数点后面或者前面以及指数项正负号的分类，最后的匹配表达式为

    ([0-9]* '.' [0-9]+ | [0-9]+ '.') ([eE][+-]? [0-9]+)?
	| [0-9]+ [eE][+-]? [0-9]+
	| '0' [xX](
		([0-9a-fA-F]* '.' [0-9a-fA-F]+ | [0-9a-fA-F]+ '.') (
			[pP][+-]? [0-9a-fA-F]+
		)?
		| [0-9a-fA-F]+ [pP][+-]? [0-9a-fA-F]+
	);

第一二行是十进制的表示，分别是是否可以省略小数点的匹配<br>
下面数行是十六进制，情况和十进制基本一样，只是可使用的字符读了a-zA-
Z<br>
float常量和int常量有一个区别是开头可以是0
## 标识符
标识符是一段以 字母下划线开头，后面由数字字母下划线组成的词语，因此为

	[a-zA-Z_][0-9a-zA-Z_]*;

大量表意错误的词语都会到这个分类里。可能会产生的词法分析错误为使用了其他字符来作为标识符，如$，@等等。并且该分类放在if，while，for等关键词下方，保证系统保留字不会被识别为标识符。

## 测试例子
测试例子共五个，三个pt正确的和两个ft错误的
### pt正确例子
第一个是pt_common.c1，这是一个由普通程序转来的例子，包含了大部分保留关键字，计算符号，大小比较，三种括号等常规的识别<br><br>

第二个是pt_annotation.c1，这里面是注释的识别，包括了各种特殊的注释

	//\
	annotation

	/\
	/annotation

	/**
	annotation***/
等等，重点是其中的\\\\n换行，对于//注释，在任何位置插入\\\\n都可识别为注释。还有一些特殊情况是//\n这样的空注释，以及在文本最后的

	/*annotation
这种靠文件结束符代替另一半*/或者//注释中换行符的注释<br><br>

第三个是pt_const.c1，这里包含了文档描述的所有情况的整数与浮点数，并且浮点数还有十六进制的表示。

### ft错误的例子
第一个ft_const_and_annotation.c1是错误常数例子和错误注释例子，常数错误主要是使用了超出范围的字符，比如八进制中使用了8，十六进制中使用了超过f的字母，以及只使用'.'，科学计数法的指数部分使用了小数点等<br>
注释部分主要是使用了\\换行时\\与换行符没有贴紧（如中间有个空格）导致识别错误。以及/**/\*/这样类型的注释，由于是非嵌套，后面的*/会识别错误。<br><br>

第二个是ft_declaration_and_common.c1，包含了一些声明错误以及使用了一些无法识别的符号
