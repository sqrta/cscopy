# Lab1-2
## 阅读paper
本次试验最大的困难在于阅读paper，第一篇paper讲述LL(\*)的paper略有一些抽象，很多地方没有例子讲的不是很清楚，我在网上搜索了与LL(\*)和antlr3相关的文档后才理解了部分内容。第二篇的叙述要合理很多，依靠例子还有函数的注释可以明白整个parser分析的过程。对于论文的理解和回答主要见lab1-answer里的回答

## 设计语法分析文件
编写语法分析文件基本完全按照C1语言的EBNF文法书写，稍有不同的地方：

    compilationUnit:
	    compilationUnit (decl | funcdef)
	    | (decl | funcdef);
    
如果直接使用 compilationUnit? 会出现有mutually recursive的报错<br>
其他地方由于助教说最好不增加非终结符因此部分地方直接用表达式替代了非终结符<br>
比如 (Int | Float) 替代了 Btype。但我觉得为了扩展性保留这些非终结符可能会更好。


## 实验测试样本
位于test_case/parser下的测试文本，pt_common.c1和pt_common2.c1是一串常规的测试文本，里面包含了绝大部分正确情况下的使用的语句。包含了符号优先级，各种变量的定义以及关键字语句。特别的是const定义的类型必须在定义时就赋值，ft例子里也检测了没有这么做的例子会报错。比较特别的是C1语言的stmt是可以推导出 Identifier ();这种类型的，这表示的是函数的调用。但因为在语法分析部分还未辨别变量和函数，即 变量 ();这样类型的句子也是正确的例子。<br>
而ft_common则是部分错误的例子,主要包括了缺少分号，缺少部分操作符，缺少括号等。特别的是const类型定义的变量必须赋值，否则会报错。其次const定义时如果没有指定int还是float生成树会跳过这个这个点保证整体语法分析不出错，并且在终端给出错误信息。此外，C1语言不支持表达式作为判断条件，也不支持将a>b这样的判断式用来赋值。均体现在错误例子里。